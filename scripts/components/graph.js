define([    'lib/react',    'highcharts-theme',    'game-logic/engine',    'lib/clib'],function(    React,    HighCharts,    Engine,    Clib){    var D = React.DOM;    var MAX_NUM_POINTS = 30;    var MARKER_RADIUS = 8;    var MEDIUM_MARKER_RADIUS = 14;    var BIG_MARKER_RADIUS = 22;    return React.createClass({        displayName: 'Graph',        chart: null,        onWagerChange: function(wagerData) {            if(!this.isMounted())                return;            wagerData.wager = Clib.satToBit(wagerData.wager);            wagerData.balance = Clib.satToBit(wagerData.balance);            var chartLength = this.chart.series[2].data.length-1;            var chartIndex = this.chart.series[2].data[this.chart.series[2].data.length - 1].x;            this.updateProjections(chartLength, chartIndex, wagerData);        },        shouldComponentUpdate: function(nextProps, nextState){            return false; //Never render        },        onNewBet: function(bet) { //The position in the array of this bet            if(!this.isMounted())                return;            bet.amount = Clib.satToBit(bet.amount);            bet.balance = Clib.satToBit(bet.balance);            bet.wager = Clib.satToBit(bet.wager);            //Change the color of the projection points            this.chart.series[0].data[0].options.marker = { fillColor: 'grey' };            this.chart.series[0].data[0].update(this.chart.series[0].data[0].options.marker, false);            this.chart.series[1].data[0].options.marker = { fillColor: 'grey' };            this.chart.series[1].data[0].update(this.chart.series[1].data[0].options.marker, false);            //Move the chart to the left adding one invisible point            var fakePoint = {                y: bet.balance,                x: this.chart.series[2].data[this.chart.series[2].data.length - 1].x + 2,                radius: 2            };            this.chart.series[3].addPoint(fakePoint);            if(this.chart.series[3].data.length > 1)                this.chart.series[3].data[0].remove(false);            console.assert(this.chart.series[3].data.length <= 1);        },        onBetFinished: function(game) {            game.amount = Clib.satToBit(game.amount);            game.balance = Clib.satToBit(game.balance);            game.wager = Clib.satToBit(game .wager);            //Create the new point and add it without redrawing            var newPoint;            var dataLabelStyle = {                enabled: true,                format: '{point.result}',                y: 10,                color: '#000000',                style: {                    fontSize: '16px',                    fontWeight: 'bold'                    //fill: '#000000'                }            };            if(game.win)                newPoint = {                    color: '#90ee7e',                    y: game.balance,                    result: game.result,                    radius: BIG_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            else                newPoint = {                    color: '#f45b5b',                    y: game.balance,                    result: game.result,                    radius: BIG_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            var chartLength = this.chart.series[2].data.length; //The real length of the chart            var chartIndex = this.chart.series[2].data[this.chart.series[2].data.length - 1].x + 1;            //Format the second and the third points            this.chart.series[2].data[chartLength-1].update({                radius: MEDIUM_MARKER_RADIUS,                dataLabels: {                    enabled: true,                    format: '{point.result}',                    y: -14                }            }, false);            if(chartLength-2 >= 0)                this.chart.series[2].data[chartLength-2].update({                    radius: MARKER_RADIUS,                    dataLabels: {                        enabled: true,                        format: '{point.result}',                        y: -8                    }                }, false);            //Add the result of the game            this.chart.series[2].addPoint(newPoint, false); //The length of the graph is not updated until render time            if(chartLength > MAX_NUM_POINTS)                this.chart.series[2].data[0].remove(false);            //Hide old projection points            this.chart.series[0].data[0].options.marker = { radius: 0 };            this.chart.series[0].data[0].update(this.chart.series[0].data[0].options);            this.chart.series[1].data[0].options.marker = { radius: 0 };            this.chart.series[1].data[0].update(this.chart.series[1].data[0].options);            //Update projections after a time            var self = this;            setTimeout(function(){                var wonProjection = game.balance + (game.wager * (98/game.winProb)) - game.wager;                var LostProjection = game.balance - game.wager;                //Delete the projections and add a new ones                self.chart.series[0].data[0].remove(false);                self.chart.series[1].data[0].remove(false);                self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);                self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                self.chart.redraw();                //Remove the wrong projection and add the rest of the points                //if(game.win) {                //    self.chart.series[0].data[0].options.marker = { radius: 4 };                //    self.chart.series[0].data[0].update([chartIndex + 1, wonProjection], false, self.chart.series[0].data[0].options    ); //Won projection                //    self.chart.series[1].data[0].options.marker = { radius: 4 };                //    self.chart.series[1].data[0].update([chartIndex + 1, LostProjection], false, self.chart.series[1].data[0].options);                    //self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false); //Won projection                    //self.chart.series[1].data[0].update([chartIndex, game.balance], false);                    //self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                //} else {                    //self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                    //self.chart.series[0].data[0].remove(false);                    //self.chart.series[0].addPoint([chartIndex, game.balance], false);                    //self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);                //}            }, 400);            this.chart.redraw();        },        updateProjections: function(chartLength, chartIndex, game) {            var wonProjection = game.balance + (game.wager * (98/game.winProb)) - game.wager;            var LostProjection = game.balance - game.wager;            this.chart.series[0].data[0].update([chartIndex + 1, wonProjection], false);            this.chart.series[1].data[0].update([chartIndex + 1, LostProjection], false);            //if(game)            //{            //    if(game.win) {            //        this.chart.series[0].data[0].remove(false);            //        this.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);            //            //        this.chart.series[1].data[0].update([chartIndex, game.balance], false);            //        this.chart.series[1].data[1].update([chartIndex + 1, LostProjection], false);            //    } else {            //        this.chart.series[0].data[0].update([chartIndex, game.balance], false);            //        this.chart.series[0].data[1].update([chartIndex + 1, wonProjection], false);            //            //        this.chart.series[1].data[0].remove(false);            //        this.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);            //    }            //}            //else            //{                /*this.chart.series[0].data[0].update([chartIndex, game.balance], false);                this.chart.series[0].data[1].update([chartIndex + 1, wonProjection], false);                this.chart.series[1].data[0].update([chartIndex, game.balance], false);                this.chart.series[1].data[1].update([chartIndex + 1, LostProjection], false);*/            //}            this.chart.redraw();        },        removeProjectionsBeginning: function(bet) {            //Add a fake point        },        componentDidMount: function() {            Engine.addWagerListener(this.onWagerChange);            Engine.addBetListener(this.onNewBet);            Engine.addBetEndListener(this.onBetFinished);            var gameState = Engine.getGameState();            gameState.wager = Clib.satToBit(gameState.wager);            gameState.balance = Clib.satToBit(gameState.balance);            gameState.maxBet = Clib.satToBit(gameState.maxBet);            this.chart = createChart(this.refs.graphBox.getDOMNode(), gameState);        },        componentWillUnmount: function() {            Engine.removeWagerListener(this.onWagerChange);            Engine.removeBetListener(this.onNewBet);            Engine.removeBetEndListener(this.onBetFinished);            this.chart.destroy();        },        render: function() {            return D.div({ id: 'graph-box', ref: 'graphBox' });        }    });    function createSeries(gameState) {        var series = [];        var profitSeries = {            data: [                { y: gameState.balance, color: '#90ee7e', radius: BIG_MARKER_RADIUS }            ],            dataLabels: {                enabled: true,                format: '{point.result}',                y: -7            }        };        //Create the won projection series        var wonProjectionSeries = {            color: "rgba(144, 238, 126, 0.5)",            data: [                //{                //    y: gameState.balance,                //    x: 0                //},                {                    y: gameState.balance + (gameState.wager * (98/gameState.winProb)) - gameState.wager,                    x: 1                }            ]        };        //Create the lost projection series        var lostProjectionSeries = {            color: "rgba(244, 91, 91, 0.5)",            data: [                //{                //    y: gameState.balance,                //    x: 0                //},                {                    y: gameState.balance - gameState.wager,                    x: 1                }            ]        };        var fakePointSeries = {            color: 'rgba(255,255,255,0.1)',            data: []        };        series.push(wonProjectionSeries);        series.push(lostProjectionSeries);        series.push(profitSeries);        series.push(fakePointSeries);        return series;    }    function createChart(node, gameState) {        return new Highcharts.Chart({            chart: {                renderTo: node,                type: 'line',                margin: [70, 50, 60, 80], //Margin around the graph container                //animation: {                //    duration: 400                //    //easing: 'easeOutQuart'                //},                events: {                    redraw: function () {                        //alert('The chart is being redrawn');                        //console.log('redraw');                    }                }                //backgroundColor: '#272B30'            },            tooltip: {                pointFormat: "Value: {point.y:,.0f} mm"            },            plotOptions: {                //line: {                //    dataLabels: {                //        enabled: true,                //        format: '{point.result:,.0f}'                //    }                //},                series: {                    lineWidth: 1,                    marker: {                        radius: MARKER_RADIUS,                        symbol: 'circle'                    }                    //animation: {                    //    duration: 2000,                    //    easing: 'easeOutBounce'                    //}                }            },            title: {                text: 'Dust Dice'                //style: {                //    color: '#ffffff',                //    fontWeight: 'bold'                //}            },            subtitle: {                text: 'The simplest casino you could find'                //style: {                //    color: '#ffffff',                //    fontWeight: 'bold'                //}            },            legend: {                enabled: false            },            xAxis: {                //gridLineWidth: 1,                //minPadding: 0.2,                //maxPadding: 0.2,                //maxZoom: 60,                //min: 0,                //max: 30,                //tickPixelInterval: 100,                //tickInterval: 1,                //minPadding: 0.2,                minRange: 30,                allowDecimals: false            },            yAxis: {                title: {                    text: 'Balance'                },                minPadding: 0.2,                maxPadding: 0.2,                maxZoom: 5,                plotLines: [{                    value: 0,                    width: 1,                    color: '#808080'                }]            },            exporting: {                enabled: false            },            series: createSeries(gameState)        });    }});