define([    'lib/react',    'highcharts-theme',    'game-logic/engine',    'lib/clib'],function(    React,    HighCharts,    Engine,    Clib){    var D = React.DOM;    var MAX_NUM_POINTS = 20;    var MARKER_RADIUS = 8;    var MEDIUM_MARKER_RADIUS = 12;    var BIG_MARKER_RADIUS = 18;    return React.createClass({        displayName: 'Graph',        chart: null,        componentDidMount: function() {            Engine.on('new-wager-data', this._onWagerChange);            Engine.on('bet-sent', this._onNewBet);            Engine.on('bet-end', this.onBetFinished);            Engine.on('history-clear', this._onHistoryClear);            this.chart = createChart(this.refs.graphBox.getDOMNode());        },        componentWillUnmount: function() {            Engine.off('new-wager-data', this._onWagerChange);            Engine.off('bet-sent', this._onNewBet);            Engine.off('bet-end', this.onBetFinished);            Engine.off('history-clear', this._onHistoryClear);            this.chart.destroy();        },        shouldComponentUpdate: function(nextProps, nextState){            return false; //Never render        },        _onHistoryClear: function() {            this.chart.destroy();            this.chart = createChart(this.refs.graphBox.getDOMNode(), getState());        },        _onWagerChange: function() {            if(!this.isMounted())                return;            var chartLength = this.chart.series[2].data.length-1;            var chartIndex = this.chart.series[2].data[this.chart.series[2].data.length - 1].x;            this.updateProjections(chartLength, chartIndex);        },        _onNewBet: function(bet) {            if(!this.isMounted())                return;            var balanceBits = Clib.satToBit(bet.balance);            var wager = Clib.satToBit(bet.wager); //Was already rounded by the engine            //Change the color of the projection points            this.chart.series[0].data[0].options.marker = { fillColor: 'grey' };            this.chart.series[0].data[0].update(this.chart.series[0].data[0].options.marker, false);            this.chart.series[1].data[0].options.marker = { fillColor: 'grey' };            this.chart.series[1].data[0].update(this.chart.series[1].data[0].options.marker, false);            //Move the chart to the left adding one invisible point            var fakePoint = {                y: balanceBits,                x: this.chart.series[2].data[this.chart.series[2].data.length - 1].x + 2,                radius: 2            };            this.chart.series[3].addPoint(fakePoint);            if(this.chart.series[3].data.length > 1)                this.chart.series[3].data[0].remove(false);            console.assert(this.chart.series[3].data.length <= 1);        },        onBetFinished: function(game) {            var balanceBits = Clib.satToBit(game.balance);            var wagerBits = Clib.satToBit(game.wager); //Was already rounded            //Create the new point and add it without redrawing            var newPoint;            var dataLabelStyle = {                enabled: true,                format: '{point.outcome}',                y: 10,                color: '#000000',                style: {                    fontSize: '16px',                    fontWeight: 'bold'                    //fill: '#000000'                }            };            var wonGame = (game.profit > 0);            if(wonGame)                newPoint = {                    color: '#90ee7e',                    y: balanceBits,                    game: game,                    outcome: game.outcome,                    radius: BIG_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            else                newPoint = {                    color: '#f45b5b',                    y: balanceBits,                    game: game,                    outcome: game.outcome,                    radius: BIG_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            var chartLength = this.chart.series[2].data.length; //The real length of the chart            var chartIndex = this.chart.series[2].data[this.chart.series[2].data.length - 1].x + 1;            //Format the second and the third points            this.chart.series[2].data[chartLength-1].update({                radius: MEDIUM_MARKER_RADIUS,                dataLabels: {                    enabled: true,                    format: '{point.outcome}',                    y: -14                }            }, false);            if(chartLength-2 >= 0)                this.chart.series[2].data[chartLength-2].update({                    radius: MARKER_RADIUS,                    dataLabels: {                        enabled: true,                        format: '{point.outcome}',                        y: -8                    }                }, false);            //Add the result of the game            this.chart.series[2].addPoint(newPoint, false); //The length of the graph is not updated until render time            if(chartLength > MAX_NUM_POINTS)                this.chart.series[2].data[0].remove(false);            //Hide old projection points            this.chart.series[0].data[0].options.marker = { radius: 0 };            this.chart.series[0].data[0].update(this.chart.series[0].data[0].options);            this.chart.series[1].data[0].options.marker = { radius: 0 };            this.chart.series[1].data[0].update(this.chart.series[1].data[0].options);            //Update projections after a time            var self = this;            setTimeout(function(){                var wonProjection = balanceBits + (wagerBits * (98/game.winProb)) - wagerBits;                var LostProjection = balanceBits - wagerBits;                //Delete the projections and add a new ones                self.chart.series[0].data[0].remove(false);                self.chart.series[1].data[0].remove(false);                self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);                self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                self.chart.redraw();                //Remove the wrong projection and add the rest of the points                //if(game.win) {                //    self.chart.series[0].data[0].options.marker = { radius: 4 };                //    self.chart.series[0].data[0].update([chartIndex + 1, wonProjection], false, self.chart.series[0].data[0].options    ); //Won projection                //    self.chart.series[1].data[0].options.marker = { radius: 4 };                //    self.chart.series[1].data[0].update([chartIndex + 1, LostProjection], false, self.chart.series[1].data[0].options);                    //self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false); //Won projection                    //self.chart.series[1].data[0].update([chartIndex, game.balanceBits], false);                    //self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                //} else {                    //self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                    //self.chart.series[0].data[0].remove(false);                    //self.chart.series[0].addPoint([chartIndex, game.balanceBits], false);                    //self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);                //}            }, 400);            this.chart.redraw();        },        updateProjections: function(chartLength, chartIndex) {            var balanceBits = Clib.satToBit(Engine.balance);            var wagerBitsRounded = Clib.satToBitRounded(Engine.wager);            var wonProjection = balanceBits + (wagerBitsRounded * (98/Engine.winProb)) - wagerBitsRounded;            var LostProjection = balanceBits - wagerBitsRounded;            this.chart.series[0].data[0].update([chartIndex + 1, wonProjection], false);            this.chart.series[1].data[0].update([chartIndex + 1, LostProjection], false);            //if(game)            //{            //    if(game.win) {            //        this.chart.series[0].data[0].remove(false);            //        this.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);            //            //        this.chart.series[1].data[0].update([chartIndex, game.balanceBits], false);            //        this.chart.series[1].data[1].update([chartIndex + 1, LostProjection], false);            //    } else {            //        this.chart.series[0].data[0].update([chartIndex, game.balanceBits], false);            //        this.chart.series[0].data[1].update([chartIndex + 1, wonProjection], false);            //            //        this.chart.series[1].data[0].remove(false);            //        this.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);            //    }            //}            //else            //{                /*this.chart.series[0].data[0].update([chartIndex, game.balanceBits], false);                this.chart.series[0].data[1].update([chartIndex + 1, wonProjection], false);                this.chart.series[1].data[0].update([chartIndex, game.balanceBits], false);                this.chart.series[1].data[1].update([chartIndex + 1, LostProjection], false);*/            //}            this.chart.redraw();        },        removeProjectionsBeginning: function(bet) {            //Add a fake point        },        render: function() {            return D.div({ id: 'graph-box', ref: 'graphBox' });        }    });    function createSeries() {        var balanceBits = Clib.satToBit(Engine.balance);        var wagerBits = Clib.satToBitRounded(Engine.wager);        var series = [];        var profitSeries = {            name: 'profit',            game: {                outcome: 0            },            data: [                { y: balanceBits, color: '#90ee7e', radius: BIG_MARKER_RADIUS }            ]            //dataLabels: {            //},        };        //Create the won projection series        var wonProjectionSeries = {            name: 'won',            color: "rgba(144, 238, 126, 0.5)",            data: [                //{                //    y: gameState.balanceBits,                //    x: 0                //},                {                    y: balanceBits + (wagerBits * (98/Engine.winProb)) - wagerBits,                    x: 1                }            ]        };        //Create the lost projection series        var lostProjectionSeries = {            name: 'lose',            color: "rgba(244, 91, 91, 0.5)",            data: [                //{                //    y: gameState.balanceBits,                //    x: 0                //},                {                    y: balanceBits - wagerBits,                    x: 1                }            ]        };        var fakePointSeries = {            color: 'rgba(255,255,255,0.1)',            data: []        };        series.push(wonProjectionSeries);        series.push(lostProjectionSeries);        series.push(profitSeries);        series.push(fakePointSeries);        return series;    }    function createChart(node) {        return new Highcharts.Chart({            chart: {                renderTo: node,                type: 'line',                //margin: null, //Dynamically calculated                //animation: {                //    duration: 400                //    //easing: 'easeOutQuart'                //},                events: {                    redraw: function () {                        //alert('The chart is being redrawn');                        //console.log('redraw');                    }                }                //backgroundColor: '#272B30'            },            tooltip: {                formatter: function() {                    if(this.series.name == 'profit' && this.point.outcome){                        var betRange = (this.point.game.hiLo === true)? ( (101-this.point.game.winProb) + ' to 100' ) : ('1 to ' + this.point.game.winProb);                        return '<b>' + 'Bet id: ' + '</b>' + this.point.game.bet_id + '<br/>\                        <b>' + 'Outcome: ' + '</b>' + this.point.outcome + '<br/>\                        <b>' + 'Range: ' + '</b>' + betRange + '<br/>\                        <b>' + 'Bet: ' + '</b>' + Clib.satToBit(this.point.game.wager) + '<br/>\                        <b>' + 'Profit: ' + '</b>' + Clib.satToBit(this.point.game.profit) + '<br/>\                        <b>' + 'Balance: ' + '</b>' + Clib.satToBit(this.point.game.balance) + '<br/>' ;                    } else {                        return false;                    }                }, style: {                    fontFamily: 'Arial',                    fontWeight: 'normal'                }            },            plotOptions: {                //line: {                //    dataLabels: {                //        enabled: true,                //        format: '{point.game.outcome:,.0f}'                //    }                //},                series: {                    lineWidth: 1,                    marker: {                        radius: MARKER_RADIUS,                        symbol: 'circle'                    }                    //animation: {                    //    duration: 2000,                    //    easing: 'easeOutBounce'                    //}                }            },            title: {                text: null                //style: {                //    color: '#ffffff',                //    fontWeight: 'bold'                //}            },            subtitle: {                //text: 'The simplest casino you could find'                //style: {                //    color: '#ffffff',                //    fontWeight: 'bold'                //}            },            legend: {                enabled: false            },            xAxis: {                //gridLineWidth: 1,                //minPadding: 0.2,                //maxPadding: 0.2,                //maxZoom: 60,                //min: 0,                //max: 30,                //tickPixelInterval: 100,                //tickInterval: 1,                //minPadding: 0.2,                minRange: 20,                allowDecimals: false,                labels: {                    enabled: false                }            },            yAxis: {                title: {                    text: 'Balance'                },                minPadding: 0.2,                maxPadding: 0.2,                maxZoom: 5,                plotLines: [{                    value: 0,                    width: 1,                    color: '#808080'                }]            },            exporting: {                enabled: false            },            series: createSeries()        });    }});