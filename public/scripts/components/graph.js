define([    'lib/react',    'highcharts-theme',    'game-logic/engine',    'lib/clib'],function(    React,    HighCharts,    Engine,    Clib){    var D = React.DOM;    var MAX_NUM_POINTS = 20;    var MAX_MEM_NUM_POINTS = 270;    var MARKER_RADIUS = 8;    var MEDIUM_MARKER_RADIUS = 12;    var BIG_MARKER_RADIUS = 18;    var JACKPOT_MARKER_RADIUS = 22;    return React.createClass({        displayName: 'Graph',        chart: null,        componentDidMount: function() {            Engine.on('new-wager', this._onWagerChange);            Engine.on('new-win-prob', this._onWagerChange);            Engine.on('bet-sent', this._onNewBet);            Engine.on('bet-end', this.onBetFinished);            Engine.on('history-clear', this._onHistoryClear);            Engine.on('new-balance', this._refreshBalance);            this.chart = createChart(this.refs.graphBox.getDOMNode());        },        componentWillUnmount: function() {            Engine.off('new-wager', this._onWagerChange);            Engine.off('new-win-prob', this._onWagerChange);            Engine.off('bet-sent', this._onNewBet);            Engine.off('bet-end', this.onBetFinished);            Engine.off('history-clear', this._onHistoryClear);            Engine.off('new-balance', this._refreshBalance);            this.chart.destroy();        },        shouldComponentUpdate: function(nextProps, nextState){            return false; //Never render        },        _onHistoryClear: function() {            this.chart.destroy();            this.chart = createChart(this.refs.graphBox.getDOMNode());        },        _onWagerChange: function() {            if(!this.isMounted())                return;            var chartLength = this.chart.series[2].data.length-1;            var chartIndex = this.chart.series[2].data[this.chart.series[2].data.length - 1].x;            this.updateProjections(chartLength, chartIndex);        },        _onNewBet: function(bet) {            if(!this.isMounted())                return;            var balanceBits = Clib.satToBit(bet.balance);            //var wager = Clib.satToBit(bet.wager); //Was already rounded by the engine            //Change the color of the projection points            //this.chart.series[0].data[0].options.marker = { fillColor: 'grey' };            //this.chart.series[0].data[0].update(this.chart.series[0].data[0].options.marker, false);            //this.chart.series[1].data[0].options.marker = { fillColor: 'grey' };            //this.chart.series[1].data[0].update(this.chart.series[1].data[0].options.marker, false);            //Move the chart to the left adding one invisible point            var fakePoint = {                y: balanceBits,                x: this.chart.series[2].data[this.chart.series[2].data.length - 1].x + 2,                radius: 2            };            this.chart.series[3].addPoint(fakePoint);            if(this.chart.series[3].data.length > 1)                this.chart.series[3].data[0].remove(false);            console.assert(this.chart.series[3].data.length <= 1);        },        onBetFinished: function(game) {            var balanceBits = Clib.satToBit(game.balance);            var wagerBits = Clib.satToBit(game.wager); //Was already rounded            //Create the new point and add it without redrawing            var newPoint;            var dataLabelStyle = {                enabled: true,                format: '{point.outcome}',                y: 10,                color: '#000000',                style: {                    fontSize: '16px',                    fontWeight: 'bold'                    //fill: '#000000'                }            };            var chartLength = this.chart.series[2].data.length; //The real length of the chart            var chartIndex = this.chart.series[2].data[this.chart.series[2].data.length - 1].x + 1;            //You can't win the jackpot and win the bet and the same time            if(game.wonJackpot)                newPoint = {                    color: '#ffbe3d',                    y: balanceBits,                    game: game,                    outcome: game.outcome,                    radius: JACKPOT_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            else if(game.wonBet)                newPoint = {                    color: '#90ee7e',                    y: balanceBits,                    game: game,                    outcome: game.outcome,                    radius: BIG_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            else if(game.newBalance)                newPoint = {                    color: '#e95bff',                    y: balanceBits,                    x: chartIndex-1,                    game: game,                    //outcome: game.outcome,                    radius: BIG_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            else                newPoint = {                    color: '#f45b5b',                    y: balanceBits,                    game: game,                    outcome: game.outcome,                    radius: BIG_MARKER_RADIUS,                    dataLabels: dataLabelStyle                };            //Format the second and the third points            this.chart.series[2].data[chartLength-1].update({                radius: MEDIUM_MARKER_RADIUS,                dataLabels: {                    enabled: true,                    format: '{point.outcome}',                    y: -14                }            }, false);            if(chartLength-2 >= 0)                this.chart.series[2].data[chartLength-2].update({                    radius: MARKER_RADIUS,                    dataLabels: {                        enabled: true,                        format: '{point.outcome}',                        y: -8                    }                }, false);            //Add the result of the game            this.chart.series[2].addPoint(newPoint, false); //The length of the graph is not updated until render time            //Set the max viewed point on the screen and delete them when they are too many            if(chartLength > MAX_NUM_POINTS) {                //If there is more than 1000 points in the series remove them                if(chartLength > MAX_MEM_NUM_POINTS)                    for(var i = 0, length = chartLength-MAX_NUM_POINTS; i < length; i++) {                        this.chart.series[2].data[i].remove(false);                    }                //var newChartLength = this.chart.series[2].data.length; //The real length of the chart                var newChartIndex = this.chart.series[2].data[this.chart.series[2].data.length - 1].x + 1;                this.chart.xAxis[0].setExtremes(                    newChartIndex-MAX_NUM_POINTS, newChartIndex+1                );            }            //Hide old projection points            this.chart.series[0].data[0].options.marker = { radius: 0 };            this.chart.series[0].data[0].update(this.chart.series[0].data[0].options);            this.chart.series[1].data[0].options.marker = { radius: 0 };            this.chart.series[1].data[0].update(this.chart.series[1].data[0].options);            //Update projections after a time            var self = this;            setTimeout(function(){                var wonProjectionDiff = (wagerBits * (98/game.winProb)) - wagerBits;                var LostProjection = balanceBits - wagerBits;                var wonProjection = wonProjectionDiff + balanceBits;                var wagerBitsRounded = wagerBits;                //Delete the projections and add a new ones, no using update projection because we delete them here                self.chart.series[0].data[0].remove(false);                self.chart.series[1].data[0].remove(false);                self.chart.series[0].addPoint({                    x: chartIndex + 1,                    y: wonProjection,                    dataLabels: {                        enabled: true,                        format: '+' + ((wonProjectionDiff % 1 !== 0)? wonProjectionDiff.toFixed(2) : wonProjectionDiff),                        y: -14                    }                }, false);                self.chart.series[1].addPoint({                    x:chartIndex + 1,                    y: LostProjection,                    dataLabels: {                        enabled: true,                        format: '-' + wagerBitsRounded, //You can't bet decimals, so no need to round it                        y: 29                    }                }, false);                self.chart.redraw();                //Remove the wrong projection and add the rest of the points                //if(game.win) {                //    self.chart.series[0].data[0].options.marker = { radius: 4 };                //    self.chart.series[0].data[0].update([chartIndex + 1, wonProjection], false, self.chart.series[0].data[0].options    ); //Won projection                //    self.chart.series[1].data[0].options.marker = { radius: 4 };                //    self.chart.series[1].data[0].update([chartIndex + 1, LostProjection], false, self.chart.series[1].data[0].options);                    //self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false); //Won projection                    //self.chart.series[1].data[0].update([chartIndex, game.balanceBits], false);                    //self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                //} else {                    //self.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);                    //self.chart.series[0].data[0].remove(false);                    //self.chart.series[0].addPoint([chartIndex, game.balanceBits], false);                    //self.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);                //}            }, 400);            this.chart.redraw();        },        _refreshBalance: function(newState) {            newState.newBalance = true;            this.onBetFinished(newState);        },        updateProjections: function(chartLength, chartIndex) {            var balanceBits = Clib.satToBit(Engine.balance);            var wagerBitsRounded = Clib.satToBitRounded(Engine.wager);            var wonProjectionDiff =  (wagerBitsRounded * (98/Engine.winProb)) - wagerBitsRounded;            var wonProjection = balanceBits + wonProjectionDiff;            var LostProjection = balanceBits - wagerBitsRounded;            this.chart.series[0].data[0].update({                x: chartIndex + 1,                y: wonProjection,                dataLabels: {                    enabled: true,                    format: '+' + ((wonProjectionDiff % 1 !== 0)? wonProjectionDiff.toFixed(2) : wonProjectionDiff),                    y: -14                }            }, false);            this.chart.series[1].data[0].update({                x:chartIndex + 1,                y: LostProjection,                dataLabels: {                    enabled: true,                    format: '-' + wagerBitsRounded,                    y: 29                }            }, false);            //if(game)            //{            //    if(game.win) {            //        this.chart.series[0].data[0].remove(false);            //        this.chart.series[0].addPoint([chartIndex + 1, wonProjection], false);            //            //        this.chart.series[1].data[0].update([chartIndex, game.balanceBits], false);            //        this.chart.series[1].data[1].update([chartIndex + 1, LostProjection], false);            //    } else {            //        this.chart.series[0].data[0].update([chartIndex, game.balanceBits], false);            //        this.chart.series[0].data[1].update([chartIndex + 1, wonProjection], false);            //            //        this.chart.series[1].data[0].remove(false);            //        this.chart.series[1].addPoint([chartIndex + 1, LostProjection], false);            //    }            //}            //else            //{                /*this.chart.series[0].data[0].update([chartIndex, game.balanceBits], false);                this.chart.series[0].data[1].update([chartIndex + 1, wonProjection], false);                this.chart.series[1].data[0].update([chartIndex, game.balanceBits], false);                this.chart.series[1].data[1].update([chartIndex + 1, LostProjection], false);*/            //}            this.chart.redraw();        },        removeProjectionsBeginning: function(bet) {            //Add a fake point        },        render: function() {            return D.div({ id: 'graph-box', ref: 'graphBox' });        }    });    function createSeries() {        var balanceBits = Clib.satToBit(Engine.balance);        var wagerBits = Clib.satToBitRounded(Engine.wager);        var wonProjectionDiff =  (wagerBits * (98/Engine.winProb)) - wagerBits;        var series = [];        var profitSeries = {            name: 'profit',            game: {                outcome: 0            },            data: [                { y: balanceBits, color: '#90ee7e', radius: BIG_MARKER_RADIUS }            ]            //dataLabels: {            //},        };        //Create the won projection series        var wonProjectionSeries = {            name: 'won',            color: "rgba(144, 238, 126, 0.5)",            data: [                //{                //    y: gameState.balanceBits,                //    x: 0                //},                {                    y: balanceBits + (wagerBits * (98/Engine.winProb)) - wagerBits,                    x: 1                }            ],            dataLabels: {                enabled: true,                format: '+' + wonProjectionDiff,                y: -14            }        };        //Create the lost projection series        var lostProjectionSeries = {            name: 'lose',            color: "rgba(244, 91, 91, 0.5)",            data: [                //{                //    y: gameState.balanceBits,                //    x: 0                //},                {                    y: balanceBits - wagerBits,                    x: 1                }            ],            dataLabels: {                enabled: true,                format: '-' + wagerBits,                y: 29            }        };        var fakePointSeries = {            color: 'transparent',            data: []        };        series.push(wonProjectionSeries);        series.push(lostProjectionSeries);        series.push(profitSeries);        series.push(fakePointSeries);        return series;    }    function createChart(node) {        return new Highcharts.Chart({            chart: {                renderTo: node,                type: 'line',                //margin: null, //Dynamically calculated                //animation: {                //    duration: 400                //    //easing: 'easeOutQuart'                //},                events: {                    redraw: function () {                        //alert('The chart is being redrawn');                        //console.log('redraw');                    }                }                //backgroundColor: '#272B30'            },            tooltip: {                formatter: function() {                    if(this.series.name == 'profit' && this.point.outcome){                        var betRange = (this.point.game.hiLo === true)? ( (101-this.point.game.winProb) + ' to 100' ) : ('1 to ' + this.point.game.winProb);                        var jackpot = this.point.game.wonJackpot? '<b>' + 'JACKPOT!'+ '<b> <br/>': '<b>' + 'BET INFO' + '</b> <br/>';                        return jackpot + '\                            ' + '--------------' + '<br/>\                            <b>' + 'Bet id: ' + '</b>' + this.point.game.bet_id + '<br/>\                            <b>' + 'Outcome: ' + '</b>' + this.point.outcome + '<br/>\                            <b>' + 'Range: ' + '</b>' + betRange + '<br/>\                            <b>' + 'Bet: ' + '</b>' + Clib.satToBit(this.point.game.wager) + '<br/>\                            <b>' + 'Profit: ' + '</b>' + Clib.satToBit(this.point.game.profit) + '<br/>\                            <b>' + 'Balance: ' + '</b>' + Clib.satToBit(this.point.game.balance) + '<br/>\                            <b>' + 'Fair Verified ' + ' \u2713' + '<br/>' ;                    } else if(this.series.name == 'profit' && this.point.game && this.point.game.newBalance) {                        return 'NEW BALANCE' + '<br/>\                                    <b>' + 'Balance: ' + Clib.satToBit(this.point.game.balance);                    } else {                        return false;                    }                }, style: {                    fontFamily: 'Arial',                    fontWeight: 'normal'                }            },            plotOptions: {                //line: {                //    dataLabels: {                //        enabled: true,                //        format: '{point.game.outcome:,.0f}'                //    }                //},                series: {                    lineWidth: 1,                    marker: {                        radius: MARKER_RADIUS,                        symbol: 'circle'                    }                    //animation: {                    //    duration: 2000,                    //    easing: 'easeOutBounce'                    //}                }            },            title: {                text: null                //style: {                //    color: '#ffffff',                //    fontWeight: 'bold'                //}            },            subtitle: {                //text: 'The simplest casino you could find'                //style: {                //    color: '#ffffff',                //    fontWeight: 'bold'                //}            },            legend: {                enabled: false            },            xAxis: {                minRange: 20,                allowDecimals: false,                labels: {                    enabled: false                }            },            yAxis: {                title: {                    text: 'Balance'                },                minTickInterval: 1,                minPadding: 0.2,                maxPadding: 0.2,                maxZoom: 5,                plotLines: [{                    value: 0,                    width: 6,                    color: 'rgb(112, 112, 115)'                }]            },            exporting: {                enabled: false            },            series: createSeries()        });    }});